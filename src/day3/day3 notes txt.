
# Day 3 :

## Review

- Creating java project and setting up local repo
- Adding `.gitignore` file
- Making initial commit by selecting all unversioned files
- Making more commits to do more work
- Publishing repository to remote GitHub.com
  - Github.com remote repository has been created for you by Intellij directly
  - Connection between local repo and remote repo is established
  - local commits get pushed to remote repository
- Now do more work make more commits
- Now we can simply `push` the local commits to remote

- If we have commits in remote repository that we do not have locally -> `pull`

---
### Getting Remote Repository to Local --> `Clone`
When you clone ,
- It will get remote repository to your local computer
- It will have connection with the remote repo
- It has all the history of that repo
- If you own this remote repo , you can directly push more commits back to remote


### Resetting the history
We can go back in time in history and remove all the history from that point on
```
1-2-3-4-5 commits
reset -- hard 3
-->  1-2-3  and all changes in 4-5 will be lost

reset soft-mixed  3
--> 1-2-3 and 4,5 will be gone from history but the changes still be there
```
---

## Branching

Branching allow you to work on new code without affecting the existing code safely.
It's like opening new timeline.

If you are satisfied with our work you can merge the changes into main timeline `master` branch.


### Task 1

1. Create a new branch called `list`
2. Create a new class under `day3` package called `ListPractice`
3. Make few commits under this branch by making few changes
4. Move your head to master
5. Merge `list` branch into `master`

### Task 2
1. Create a new branch called `set`
2. Create a new class under `day3` package called `SetPractice`
3. Make few commits under this branch by making few changes
4. Move your head to master
5. Remove the `--no--ff` option before merging
6. Merge `list` branch into `master`


### Task 3

1. Create a new branch `tc100`
2. Update the movie class and make few commits
3. now let's `checkout master` and generate conflict by updating same Movie class with different content
4. commit this change in master
5. Merge `tc100` into master and deal with the conflict in 4 ways:
   1. Abort the merge (`git` -> `Abort merge`)
   2. `Accept Theirs` to keep `tc100` version of the change
   3. `Accept Yours` to keep `master` version
   4. `merge` to have custom content as merge result

### Task 4
1. Create a new branch `tc200`
2. Create new Class called `Car`
3. Make some changes and do 2 commits
4. now let's `checkout master`
5. Create a new class called `Animal`
6. commit this change in master
7. Merge `tc200` into `master` and see the result
8. **CONFLICT** OR **NO CONFLICT** ?  NO


### Task 5
1. Push all your local master commits to stay in sync with the remote
2. Go to Github.com and update `FromGitHub.txt` file with different content and commit directly on Github.com
3. Now from IntelliJ `fetch` to see the commit from the remote (just to get the info)
4. `Update Project` (`pull`) to get this changes from remote to local --> No conflict

### Task 6
1. On your local, update `FromGithub.txt` and commit
2. On your remote , update `FromGithub.txt` with different content and commit (to simulate your team member pushed different update)
3. On your local , try to push this changes , it will be rejected because you have to `pull` down the changes before you can `push`
4. It will give you option to `pull` and `merge` click on merge and boom! conflict !!
5. Now resolve the conflict with the technique you learned previously
   1. `Accept Theirs` to keep `tc100` version of the change
   2. `Accept Yours` to keep `master` version
   3. `merge` to have custom content as merge result
6. Now Push your result to the remote
7. This is very common scenario while working with team members
```
